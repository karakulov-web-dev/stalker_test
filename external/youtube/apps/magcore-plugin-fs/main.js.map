{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/main.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","baseMountPath","defaultMediaTypes","video","audio","image","text","playlist","diskImage","record","activeRegisterTypes","tools","Fs","config","self","this","ext2Type","mountPath","app","mediaTypes","options","types","registered","keys","reduce","pull","type","concat","playable","forEach","ext","set","fn","stbEvent","addListener","event","broadcast","message","parseError","error","cause","line","stack","asyncCall","callback","params","slice","arguments","setTimeout","apply","getReadOnlyState","core","environment","mount_media_ro","readDir","path","data","gSTB","SetListFilesExt","join","eval","ListDir","dirs","acc","item","files","readFile","RDir","setTypes","getMountPoints","snList","info","JSON","parse","GetStorageInfo","Array","isArray","result","errMsg","length","mediaType","sn","label","trim","vendor","model","replace","partitionNum","sort","getHDDInfo","removeDir","command","charAt","substr","removeFile","createDir","ExecAction","isFolderExist","isFileUTF8Encoded","IsFileUTF8Encoded","isFileExist","IsFileExist","IsFolderExist","mount","login","pass","status","address","umount","mounted","force","onAppInit"],"mappings":"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","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * MAGSDK basic implementation of fs plugin.\n *\n * @author Yaroslav Surilov <y.surilov@infomir.com>\n */\n\n\nvar baseMountPath     = '/ram/mnt',\n    defaultMediaTypes = {\n        video: [\n            'mpg', 'mpeg', 'mov', 'mp4', 'avi', 'mkv', '3gp', 'ts', 'vob', 'wmv', 'mts', 'm2t', 'm2v',\n            'divx', 'm2ts', 'm2p', 'tp', 'flv', 'mod', 'tod', 'asf', 'tts', 'm4v', 'trp', 'wtv'\n        ],\n        audio: ['mp3', 'wav', 'ac3', 'ogg', 'oga', 'aiff', 'wv', 'tta', 'wma', 'aac', 'dts', 'flac', 'ape', 'm4a'],\n        image: ['jpg', 'jpeg', 'png', 'bmp', 'tif', 'tiff', 'raw', 'gif', 'cr2', 'nef', 'orf', 'iiq', 'ico', 'psd', 'webp', 'tif', 'tiff'],\n        text:  ['txt', 'srt', 'sub', 'ass'],\n        playlist:  ['cue', 'm3u', 'm3u8'],\n        diskImage: ['iso'],\n        record:    ['tspinf']\n    },\n    activeRegisterTypes,\n    tools;\n\n\ntools = {\n    /**\n     * Construct relatively comprehensive info about error.\n     *\n     * @param {Object} error error object\n     * @param {string} error.cause custom field which describes error cause\n     * @param {string} error.line line where error happens\n     * @param {string} error.message what is actually happened\n     * @param {string} error.stack error stack\n     *\n     * @return {string} constructed error message\n     */\n    parseError: function ( error ) {\n        return 'Error in magcore-plugin-fs plugin!' +\n               '\\nAction: '  + error.cause +\n               '\\nLine: '    + error.line +\n               '\\nMessage: ' + error.message +\n               '\\nStack:\\n'  + error.stack;\n    },\n    /**\n     * Call given callback with arbitrary set of parameters in async manner.\n     *\n     * @param {function} callback callback function to call\n     */\n    asyncCall: function ( callback ) {\n        var params = [].slice.call(arguments, 1);\n\n        setTimeout(function () {\n            try {\n                callback.apply(null, params);\n            } catch ( error ) {\n                throw error;\n            }\n        }, 0);\n    }\n};\n\n\n/**\n * @constructor\n *\n * @param {Object} config configuration options\n *\n * @example\n * var fs = core.plugins.fs;\n *\n * // get all registered extensions for \"video\" file type\n * fs.mediaTypes.video\n *\n * // get file type by its extension\n * fs.ext2Type['mp4']\n *\n * // get extensions of playable files\n * fs.mediaTypes.playable\n *\n * // get all registered file extensions\n * fs.mediaTypes.registered\n */\nfunction Fs ( config ) {\n    'use strict';\n\n    var self = this;\n\n    this.ext2Type = {};\n\n    this.mountPath = config.app && config.app.mountPath || baseMountPath;\n\n    this.mediaTypes = (config.options || {}).mediaTypes || defaultMediaTypes;\n\n    this.types = this.mediaTypes.registered = Object.keys(this.mediaTypes).reduce(function ( pull, type ) {\n        if ( type !== 'registered' && type !== 'playable' ) {\n            return pull.concat(self.mediaTypes[type]);\n        }\n\n        return pull;\n    }, []);\n\n    this.mediaTypes.playable = this.mediaTypes.video.concat(\n        this.mediaTypes.audio,\n        this.mediaTypes.image,\n        this.mediaTypes.playlist,\n        this.mediaTypes.diskImage\n    );\n\n    Object.keys(this.mediaTypes).forEach(function ( type ) {\n        self.mediaTypes[type].forEach(function ( ext) {\n            self.ext2Type[ext] = type;\n        });\n    });\n\n    Object.defineProperty(this, 'onMount', { // eslint-disable-line\n        set: function ( fn ) {\n            stbEvent.addListener('message', function ( event ) { // eslint-disable-line\n                if ( event.broadcast ) {\n                    if ( event.message === 'storage.mount' ) {\n                        fn(true);\n                    } else if ( event.message === 'storage.unmount' ) {\n                        fn(false);\n                    }\n                }\n            });\n        }\n    });\n}\n\n\n/**\n * Get read-only storage access status.\n *\n * @return {boolean} is device mounted in read-only mode\n */\nFs.prototype.getReadOnlyState = function () {\n    return core.environment.mount_media_ro === 'true'; // eslint-disable-line\n};\n\n\n/**\n * Asynchronously read the contents of a directory.\n *\n * @param {string} path path to the directory in file system\n * @param {function} callback method to invoke with a result of operation\n */\nFs.prototype.readDir = function ( path, callback ) {\n    var data;\n\n    if ( this.types !== activeRegisterTypes ) {\n        gSTB.SetListFilesExt('.' + this.types.join(' .'));\n        activeRegisterTypes = this.types;\n    }\n\n    try {\n        // two local variables occur: \"dirs\" and \"files\".\n        eval(gSTB.ListDir(path, true));\n\n        data = {\n            dirs: dirs.reduce(function ( acc, item ) { // eslint-disable-line\n                return acc.concat(item === '' ? [] : {name: item.slice(0, -1), type: 9});\n            }, []),\n            files: files.reduce(function ( acc, item ) { // eslint-disable-line\n                return item.name ? acc.concat(item) : acc;\n            }, [])\n        };\n\n        tools.asyncCall(callback, null, data);\n    } catch ( error ) {\n        error.cause = '[readDir] invalid data from gSTB.listDir';\n        tools.asyncCall(callback, tools.parseError(error));\n    }\n};\n\n\n/**\n * Asynchronously read the file..\n *\n * @param {string} path path to the file in file system\n * @param {function} callback method to invoke with a result of operation\n */\nFs.prototype.readFile = function ( path, callback ) {\n    'use strict';\n\n    tools.asyncCall(callback, null, gSTB.RDir('GetFile \"' + path + '\"'));\n};\n\n\n/**\n * Set new register file types dynamically.\n *\n * @param {Object[]} types new set of file types\n */\nFs.prototype.setTypes = function ( types ) {\n    'use strict';\n\n    this.types = this.mediaTypes.registered = types;\n};\n\n\n/**\n * List of all mounted partitions.\n *\n * @return {Object} mount points in a form of a set of objects\n */\nFs.prototype.getMountPoints = function () {\n    'use strict';\n\n    var snList = {}, // Set of all serial numbers with amount of partitions on each\n        info   = JSON.parse(gSTB.GetStorageInfo('{}')); // Get mount points\n\n    // valid non-empty data\n    if ( Array.isArray(info.result) && info.errMsg === '' && info.result.length > 0 ) {\n        info.result.forEach(function ( item ) {\n            // SD card-reader support\n            item.mediaType = item.sn === '000022272228' ? 3 : item.mediaType;\n            item.label = item.label.trim();\n\n            if ( snList[item.sn] ) {\n                snList[item.sn]++;\n            } else {\n                snList[item.sn] = 1;\n            }\n        });\n\n        info.result.forEach(function ( item ) {\n            if ( !item.label ) {\n                item.label = item.vendor + ' ' + item.model.replace(/\\//, '');\n                if ( snList[item.sn] > 1 ) {\n                    item.label += ' #' + item.partitionNum;\n                }\n            }\n        });\n\n        // Sort by mount path\n        info.result.sort();\n\n        // Final list of all combined data\n        return info.result;\n    }\n \n    return [];\n};\n\n\n/**\n * Get low-level information about mounted HDDs.\n *\n * @return {Object[]} info of connected HDD\n */\nFs.prototype.getHDDInfo = function () {\n    'use strict';\n\n    try {\n        return JSON.parse(gSTB.RDir('get_hdd_info') || '[]');\n    } catch ( error ) {\n        return [];\n    }\n};\n\n\n/**\n * Delete particular folder.\n *\n * @param {string} path path to the file system object\n * @param {function} callback method to invoke with a result of operation\n */\nFs.prototype.removeDir = function ( path, callback ) {\n    'use strict';\n\n    var command = 'RemoveDirFull \"' + (path.charAt(path.length - 1) === '/' ? path.substr(0, path.length - 1) : path) + '\"';\n\n    tools.asyncCall(callback, null, gSTB.RDir(command) === 'Ok');\n};\n\n\n/**\n * Delete particular file.\n *\n * @param {string} path path to the file system object\n * @param {function} callback method to invoke with a result of operation\n */\nFs.prototype.removeFile = function ( path, callback ) {\n    'use strict';\n\n    tools.asyncCall(callback, null, gSTB.RDir('RemoveFile \"' + path + '\"') === 'Ok');\n};\n\n\n/**\n * Create directory by specified path.\n *\n * @param {string} path path for directory creation\n * @param {function} callback method to invoke with a result of operation\n */\nFs.prototype.createDir = function ( path, callback ) {\n    'use strict';\n\n    var self = this;\n\n    gSTB.ExecAction('make_dir \"' + path + '\"');\n\n    tools.asyncCall(function () {\n        self.isFolderExist(path, function ( error, result ) {\n            if ( error ) {\n                callback(error);\n            } else {\n                callback(null, result);\n            }\n        });\n    });\n};\n\n\n/**\n * Check if the given file has UTF8 encoding.\n *\n * @param {string} path file to test\n *\n * @return {boolean} result of operation\n */\nFs.prototype.isFileUTF8Encoded = function ( path ) {\n    'use strict';\n\n    return gSTB.IsFileUTF8Encoded(path);\n};\n\n\n/**\n * Test is file name point to existing file.\n *\n * @param {string} path absolute file path which will be tested\n * @param {function} callback method to invoke with a result of operation\n */\nFs.prototype.isFileExist = function ( path, callback ) {\n    'use strict';\n\n    tools.asyncCall(callback, null, gSTB.IsFileExist(path));\n};\n\n\n/**\n * Test is file name point to existing folder.\n *\n * @param {string} path absolute file path which will be tested\n * @param {function} callback method to invoke with a result of operation\n */\nFs.prototype.isFolderExist = function ( path, callback ) {\n    'use strict';\n\n    tools.asyncCall(callback, null, gSTB.IsFolderExist(path));\n};\n\n\n/**\n * Mount shared directory.\n *\n * @param {Object} config mount options\n * @param {string} config.address ip address\n * @param {string} config.login needed login\n * @param {string} config.pass needed pass\n * @param {function} callback method to invoke with a result of operation\n */\nFs.prototype.mount = function ( config, callback ) {\n    'use strict';\n\n    var login,\n        pass,\n        command,\n        status;\n\n    if ( config && config.address ) {\n        config.address = config.address.charAt(config.address.length - 1) === '/' ?\n            config.address.substr(0, config.address.length - 1) :\n            config.address;\n        login = config.login || 'guest';\n        pass = config.pass ||  '';\n        command = 'mount cifs \"' + config.address +\n            '\" \"' + (config.mountPath || this.mountPath) +\n            '\" username=' + login +\n            ',password=' + pass +\n            ',iocharset=utf8';\n        status = gSTB.RDir(command).trim();\n    }\n\n    tools.asyncCall(callback, null, status === 'Ok');\n};\n\n\n/**\n * Umount folder (for example nfs or smb).\n *\n * @param {Object} config umount options\n * @param {boolean} config.force [force=false] flag to forcefully umount the resource\n * @param {boolean} config.mounted is directory already mounted\n * @param {boolean} config.path path for umount\n */\nFs.prototype.umount = function ( config ) {\n    'use strict';\n\n    if ( config.mounted || config.force ) {\n        gSTB.ExecAction('umount_dir ' + config.path);\n    }\n};\n\n\nmodule.exports = {\n    onAppInit: function ( config, callback ) {\n        // dome some asynchronous operations\n        callback(null, new Fs(config));\n    }\n};\n"],"sourceRoot":""}